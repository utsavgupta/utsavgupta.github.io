---
title: "Unison: A Datastore migration library for Google Go"
date: 2020-03-18T00:25:51+01:00
comments: true
slug: "unison-datastore-migration-go"
tags: ["unison", "datastore", "go"]

showpagemeta: true
draft: true
---

Unison is a lightweight library that allows you to version and manage your Datastore migrations. In this blog article we will have a look at how you can install the Unison command line tool and get started migrating entities to Datastore.

*Note: At the time of writing this article the library was not compatible with Google Firestore*

*Before we begin, the article assumes that you have Google Go installed on your computer. In case you do not have it installed, [click here](https://golang.org/dl/) to grab an installer for your operating system.* 

The go-unison project comprises two packages, viz, unison and unisoner. The first is the library that you will use to migrate your scripts, while the latter is a command line tool that lets you generate new migration scripts.

In this tutorial let's create a migration script that migrates some delicious fruits to Datastore. Run the following commands to set up your project.

```bash
$ mkdir goapp
$ cd goapp
goapp $ go mod init goapp
goapp $ go get cloud.google.com/go/datastore
goapp $ mkdir ent
goapp $ touch ent/fruits.go
goapp $ touch main.go
```
The `ent/fruits.go` file should contain the serializable Datastore entity structure as follows.

```go
package ent

type Fruit struct {
    ID   string `datastore:"id"`
    Name string `datastore:"Name"`
}
```

Now let's go ahead and install the unisoner command line tool and the unison library.

```bash
goapp $ go get github.com/utsavgupta/go-unison/unisoner
goapp $ go get github.com/utsavgupta/go-unison/unison
```

We are now ready to create new migration files. When your execute the unisoner command it creates the following to bootstrap unison.

- *Migration package*: A new package is created in the present working directory. By default the name of this package is migration. But this can be overridden by either setting the environment variable `unison_migration_package` or by passing `--migration_package <pkg_name>` while executing the command. Note: if values are received from both, environment variable and the command line param, the latter will gain precedence.
- *Unison migrations type*: A new type gets created within the above package. It is on this type new migrations will be defined. Finally an instance of this type needs to be passed to the unison library for it to work its magic.

Now with the details out of the way let's create our first migration script.

```bash
goapp $ unisoner --migration_package gcp
Filename [.go extension is automatically appended] (default -> Apply1584396052): fruits
Description: add fruits
```

Let's examine the files that were generated by unison.

```bash
goapp $ ls gcp/
fruits.go   unison.go
```

The file unison.go contains the migrations type that has been explained above. The other file is where the migration script goes. 

aaOpen `fruits.go` in a text editor and the contents should look like the following.

```go
package gcp

import (
    "cloud.google.com/go/datastore"
)

// Apply1584396052 add fruits
func (u *UnisonMigrations) Apply1584396052(t *datastore.Transaction, ns string) error {

    return nil
}
```

Each migration file we generate should ideally contain one method defined on UnisonMigrations. These method names are based on the following naming convention `Apply<Timestamp>`. It is based on this timestamp that the unison library sorts the order of migrations. A migration once successfully commited *will not* be run again. Only migrations that have a timestamp greater than the last successully executed migration will be executed.

Since I love eating apples and mangoes, I will migrate these two fruits to Datastore first. Let's make the following changes to fruits.go.

```go
package gcp

import (
    "goapp/ent"

    "cloud.google.com/go/datastore"
)

// Apply1584396052 add fruits
func (u *UnisonMigrations) Apply1584396052(t *datastore.Transaction, ns string) error {

    fruits := []ent.Fruit{
		ent.Fruit{ID: "apple", Name: "Apple"},
		ent.Fruit{ID: "mango", Name: "Mango"},
	}

	keys := make([]*datastore.Key, len(fruits))

	for idx, fruit := range fruits {
		keys[idx] = datastore.NameKey("Fruits", fruit.ID, nil)
	    keys[idx].Namespace = ns
	}

	_, err := t.PutMulti(keys, artists)

	return err
}
```

Great out first migration script is ready. Now all that remains is to use the unison library to migrate this script. For that let's make changes to `main.go`.

```go
package gcp

import (
    "context"

    "goapp/gcp"

    "cloud.google.com/go/datastore"
    "github.com/utsavgupta/go-unison/unison"
)

const (
	namespace = "unison-demo"
)

func main() {

	dsClient, err := datastore.NewClient(context.Background(), "*detect-project-id*")

	if err != nil {
		panic(err)
	}

	var unisonMigrations gcp.UnisonMigrations

	unison.RunMigrations(dsClient, namespace, &unisonMigrations)
}
```

We are a step away from migrating our first entities to Datastore. Before running the code make sure you have Google application credentials set. More on it [here](https://cloud.google.com/docs/authentication/production).


*Please note: The project is in it's early stages. Contributions in terms of bug reports, documentation, and testing are welcome. Do not hesitate to report issues or raise pull requests.*